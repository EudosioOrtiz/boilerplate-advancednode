'use strict';
require('dotenv').config();
const express = require('express');
const myDB = require('./connection');
const fccTesting = require('./freeCodeCamp/fcctesting.js');
const session = require('express-session');
const passport = require('passport');
const routes = require('./routes.js');
const auth = require('./auth.js');

const app = express();

const http = require('http').createServer(app);
const io = require('socket.io')(http);
const passportSocketIo = require('passport.socketio');
const cookieParser = require('cookie-parser');
const MongoStore = require('connect-mongo')(session);
const URI = process.env.MONGO_URI;
const store = new MongoStore({ url: URI });

app.set('view engine', 'pug');
app.set('views', './views/pug');

app.use(session({
  secret: process.env.SESSION_SECRET,
  resave: true,
  saveUninitialized: true,
  cookie: { secure: false }
}));

app.use(passport.initialize());
app.use(passport.session());

fccTesting(app); // For fCC testing purposes
app.use('/public', express.static(process.cwd() + '/public'));
app.use(express.json());
app.use(express.urlencoded({ extended: true }));

io.use(
  passportSocketIo.authorize({
    cookieParser: cookieParser,
    key: 'express.sid',
    secret: process.env.SESSION_SECRET,
    store: store,
    success: onAuthorizeSuccess,
    fail: onAuthorizeFail
  })
);

myDB(async client => {
  const myDataBase = await client.db('database').collection('users');

  routes(app, myDataBase);
  auth(app, myDataBase);

  let currentUsers = 0;
  io.on('connection', (socket) => {
    ++currentUsers;
    io.emit('user', {
      username: socket.request.user.username,
      currentUsers,
      connected: true
    });
    socket.on('chat message', (message) => {
      io.emit('chat message', { username: socket.request.user.username, message });
    });
    console.log('A user has connected');
    socket.on('disconnect', () => {
      console.log('A user has disconnected');
      --currentUsers;
      io.emit('user', {
        username: socket.request.user.username,
        currentUsers,
        connected: false
      });
    });
  });

}).catch(e => {
  app.route('/').get((req, res) => {
    res.render('index', { title: e, message: 'Unable to connect to database' });
  });
});

function onAuthorizeSuccess(data, accept) {
  console.log('successful connection to socket.io');
  console.log('user ' + socket.request.user.username + ' connected');
  accept(null, true);
}

function onAuthorizeFail(data, message, error, accept) {
  if (error) throw new Error(message);
  console.log('failed connection to socket.io:', message);
  accept(null, false);
}

const PORT = process.env.PORT || 3000;
http.listen(PORT, () => {
  console.log(`Listening on port ${PORT}`);
});


/*It's time to set up Passport so you can finally start 
allowing a user to register or log in to an account. 
In addition to Passport, you will use Express-session to handle sessions. 
Express-session has a ton of advanced features you can use, but for now 
you are just going to use the basics. Using this middleware saves 
the session id as a cookie in the client, and allows us to access 
the session data using that id on the server. This way, you keep personal 
account information out of the cookie used by the client to tell to your 
server clients are authenticated and keep the key to access the data stored 
on the server. */

/*Serialization and deserialization are important concepts in regard 
to authentication. To serialize an object means to convert its contents 
into a small key that can then be deserialized into the original object. 
This is what allows us to know who has communicated with the server 
without having to send the authentication data, like the username and password,
at each request for a new page. */

/*The callback function passed to serializeUser is called with two arguments: 
the full user object, and a callback used by passport.
The callback expects two arguments: An error, if any, and a unique key 
to identify the user that should be returned in the callback. 
You will use the user's _id in the object. This is guaranteed to be unique, 
as it is generated by MongoDB.
Similarly, deserializeUser is called with two arguments: the unique key, 
and a callback function.
This callback expects two arguments: An error, if any, and the full 
user object. To get the full user object, make a query search for a 
Mongo _id, as shown below: */

/*You are not loading an actual user object since the database is not set up. 
Connect to the database once, when you start the server, and keep a 
persistent connection for the full life-cycle of the app. To do this, 
add your database's connection string 
(for example: mongodb+srv://<username>:<password>@cluster0-jvwxi.mongodb.net/?retryWrites=true&w=majority) 
// to the environment variable MONGO_URI. This is used in the connection.js file.

If you are having issues setting up a free database on MongoDB Atlas, 
check out this tutorial.

Now you want to connect to your database, then start listening for requests. 
The purpose of this is to not allow requests before your database is 
connected or if there is a database error. To accomplish this, 
encompass your serialization and app routes in the following code: */

/*A strategy is a way of authenticating a user. You can use a strategy 
for allowing users to authenticate based on locally saved information 
(if you have them register first) or from a variety of providers 
such as Google or GitHub. For this project, we will use Passport middleware. 
Passport provides a comprehensive set of strategies that support 
authentication using a username and password, GitHub, Google, and more. 

Tell passport to use an instantiated LocalStrategy object with a few 
settings defined. Make sure this (as well as everything from this point on) 
is encapsulated in the database connection since it relies on it!:

This is defining the process to use when you try to authenticate someone 
locally. First, it tries to find a user in your database with the username 
entered. Then, it checks for the password to match. 
Finally, if no errors have popped up that you checked for 
(e.g. an incorrect password), the user object is returned and they are authenticated.

Many strategies are set up using different settings. Generally, 
it is easy to set it up based on the README in that strategy's repository. 
A good example of this is the GitHub strategy where you don't need to
worry about a username or password because the user will be sent to 
GitHub's auth page to authenticate. As long as they are logged in and 
agree then GitHub returns their profile for you to use.
*/

/*In the res.render for that page, add a new variable to the object, 
showLogin: true. When you refresh your page, you should then see the form! 
This form is set up to POST on /login. So, this is where you should set up 
to accept the POST request and authenticate the user.

For this challenge, you should add the route /login to accept a POST request. 
To authenticate on this route, you need to add a middleware to do so before 
then sending a response. This is done by just passing another argument 
with the middleware before with your response. The middleware to use 
is passport.authenticate('local').

passport.authenticate can also take some options as an argument such as 
{ failureRedirect: '/' } which is incredibly useful, so be sure to add 
 that in as well. Add a response after using the middleware 
 (which will only be called if the authentication middleware passes) 
 that redirects the user to /profile. Add that route, as well, 
 and make it render the view profile.pug.

If the authentication was successful, the user object will be saved 
in req.user.

At this point, if you enter a username and password in the form, 
it should redirect to the home page /, and the console of your server 
should display 'User {USERNAME} attempted to log in.', 
since we currently cannot login a user who isn't registered. */

/*As is, any user can just go to /profile whether they have authenticated 
or not by typing in the URL. You want to prevent this by checking if 
the user is authenticated first before rendering the profile page. 
This is the perfect example of when to create a middleware.

The challenge here is creating the middleware function 
ensureAuthenticated(req, res, next), which will check if a 
user is authenticated by calling Passport's isAuthenticated 
method on the request which checks if req.user is defined. 
If it is, then next() should be called. Otherwise, you can 
just respond to the request with a redirect to your homepage to login 

function ensureAuthenticated(req, res, next) {
  if (req.isAuthenticated()) {
    return next();
  }
  res.redirect('/');
};

Create the above middleware function, then pass ensureAuthenticated 
as middleware to requests for the profile page before the argument 
to the GET request:
app
 .route('/profile')
 .get(ensureAuthenticated, (req,res) => {
    res.render('profile');
 });
*/

/*Now that you can ensure the user accessing the /profile is authenticated, 
you can use the information contained in req.user on your page.

Pass an object containing the property username and value of req.user.username 
as the second argument for the render method of the profile view.
Also, in profile.pug, add a link referring to the /logout route, 
which will host the logic to unauthenticate a user:

a(href='/logout') Logout */

/*Creating the logout logic is easy. The route should just unauthenticate the user, and 
redirect to the home page instead of rendering any view.

In passport, unauthenticating a user is as easy as just calling req.logout() before redirecting. 
Add this /logout route to do that:

app.route('/logout')
  .get((req, res) => {
    req.logout();
    res.redirect('/');
});
You may have noticed that you are not handling missing pages (404). The common way to 
handle this in Node is with the following middleware. Go ahead and add this in after all 
your other routes:

app.use((req, res, next) => {
  res.status(404)
    .type('text')
    .send('Not Found');
}); */

/*Going back to the information security section, you may remember that storing 
plaintext passwords is never okay. Now it is time to implement BCrypt 
to solve this issue.

bcrypt@~5.0.0 has already been added as a dependency, so require it in your server. 
You will need to handle hashing in 2 key areas: where you handle registering/saving 
a new account, and when you check to see that a password is correct on login.

Currently on your registration route, you insert a user's plaintext password into 
the database like so: password: req.body.password. Hash the passwords instead by 
adding the following before your database logic: 
const hash = bcrypt.hashSync(req.body.password, 12);, and replacing 
the req.body.password in the database saving with just password: hash.

On your authentication strategy, you check for the following in your code before 
completing the process: 
if (password !== user.password) return done(null, false);. 
After making the previous changes, now user.password is a hash. 
Before making a change to the existing code, notice how the statement is 
checking if the password is not equal then return non-authenticated. 
With this in mind, change that code to look as follows to properly check the 
password entered against the hash:

if (!bcrypt.compareSync(password, user.password)) { 
  return done(null, false);
}
That is all it takes to implement one of the most important security features 
when you have to store passwords. */

/*Right now, everything you have is in your server.js file. This can lead to hard 
to manage code that isn't very expandable. Create 2 new files: routes.js and auth.js
Both should start with the following code:

module.exports = function (app, myDataBase) {

}
Now, in the top of your server file, require these files like so: 
const routes = require('./routes.js'); Right after you establish a 
successful connection with the database, instantiate each of them like so: 
routes(app, myDataBase)

Finally, take all of the routes in your server and paste them into your new files, 
and remove them from your server file. Also take the ensureAuthenticated function, 
since it was specifically created for routing. Now, you will have to correctly 
add the dependencies in which are used, such as const passport = require('passport');, 
at the very top, above the export line in your routes.js file.

Keep adding them until no more errors exist, and your server file no longer 
has any routing (except for the route in the catch block)!

Do the same thing in your auth.js file with all of the things related 
to authentication such as the serialization and the setting up of the local strategy 
and erase them from your server file. Be sure to add the dependencies in and 
call auth(app, myDataBase) in the server in the same spot.*/

/*The following challenges will make use of the chat.pug file. 
So, in your routes.js file, add a GET route pointing to /chat which 
makes use of ensureAuthenticated, and renders chat.pug, 
with { user: req.user } passed as an argument to the response. 
Now, alter your existing /auth/github/callback route to set 
the req.session.user_id = req.user.id, and redirect to /chat.

socket.io@~2.3.0 has already been added as a dependency, 
so require/instantiate it in your server as follows with 
http (comes built-in with Nodejs):

const http = require('http').createServer(app);
const io = require('socket.io')(http);
Now that the http server is mounted on the express app, you need 
to listen from the http server. Change the line with app.listen to http.listen.

The first thing needing to be handled is listening for a new connection 
from the client. The on keyword does just that- listen for a specific event. 
It requires 2 arguments: a string containing the title of the event that's emitted, 
and a function with which the data is passed through. 
In the case of our connection listener, use socket to define the data 
in the second argument. A socket is an individual client who is connected.

To listen for connections to your server, add the following within your database connection:

io.on('connection', socket => {
  console.log('A user has connected');
});
Now for the client to connect, you just need to add the following to 
your client.js which is loaded by the page after you've authenticated:

/*global io*/
/*let socket = io();
The comment suppresses the error you would normally see since 'io' is 
not defined in the file. You have already added a reliable CDN to the Socket.
IO library on the page in chat.pug.

Now try loading up your app and authenticate and you should see in 
your server console A user has connected.

Note:io() works only when connecting to a socket hosted on 
the same url/server. For connecting to an external socket hosted elsewhere, 
you would use io.connect('URL');. */

/*Emit is the most common way of communicating you will use. 
When you emit something from the server to 'io', you send an event's name 
and data to all the connected sockets. A good example of this concept 
would be emitting the current count of connected users each time a new user connects!

Start by adding a variable to keep track of the users, just before 
where you are currently listening for connections.

let currentUsers = 0;
Now, when someone connects, you should increment the count before emitting the count. 
So, you will want to add the incrementer within the connection listener.

++currentUsers;
Finally, after incrementing the count, you should emit the 
event (still within the connection listener). The event should be 
named 'user count', and the data should just be the currentUsers.

io.emit('user count', currentUsers);
Now, you can implement a way for your client to listen for 
this event! Similar to listening for a connection on the server, 
you will use the on keyword.

socket.on('user count', function(data) {
  console.log(data);
});
Now, try loading up your app, authenticate, and you should see 
in your client console '1' representing the current user count! 
Try loading more clients up, and authenticating to see the number go up. */

/*You may notice that up to now you have only been increasing the user count. 
Handling a user disconnecting is just as easy as handling the initial connect, 
except you have to listen for it on each socket instead of on the whole server.

To do this, add another listener inside the existing 'connect' listener that 
listens for 'disconnect' on the socket with no data passed through. 
You can test this functionality by just logging that a user has disconnected to the console.

socket.on('disconnect', () => {
  anything you want to do on disconnect
});
To make sure clients continuously have the updated count of current users, 
you should decrease currentUsers by 1 when the disconnect happens 
then emit the 'user count' event with the updated count.

Note: Just like 'disconnect', all other events that a socket can emit 
to the server should be handled within the connecting listener 
where we have 'socket' defined. */

/*Currently, you cannot determine who is connected to your web socket. 
While req.user contains the user object, that's only when your user 
interacts with the web server, and with web sockets you have no req (request) 
and therefore no user data. One way to solve the problem of knowing 
who is connected to your web socket is by parsing and decoding the cookie 
that contains the passport session then deserializing it to obtain the user object. 
Luckily, there is a package on NPM just for this that turns a once complex 
task into something simple!

passport.socketio@~3.7.0, connect-mongo@~3.2.0, and cookie-parser@~1.4.5 have 
already been added as dependencies. 
Require them as passportSocketIo, MongoStore, and cookieParser respectively. 
Also, we need to initialize a new memory store, from express-session 
which we previously required. It should look like this:

const MongoStore = require('connect-mongo')(session);
const URI = process.env.MONGO_URI;
const store = new MongoStore({ url: URI });
Now we just have to tell Socket.IO to use it and set the options. 
Be sure this is added before the existing socket code and not in 
the existing connection listener. For your server, it should look like this:

io.use(
  passportSocketIo.authorize({
    cookieParser: cookieParser,
    key: 'express.sid',
    secret: process.env.SESSION_SECRET,
    store: store,
    success: onAuthorizeSuccess,
    fail: onAuthorizeFail
  })
);
Note that configuring Passport authentication for Socket.IO is very similar 
to the way we configured the session middleware for the API. 
This is because they are meant to use the same authentication 
method — get the session id from a cookie and validate it.

Previously, when we configured the session middleware, we didn't explicitly 
set the cookie name for session (key). This is because the session 
package was using the default value. Now that we've added another 
package which needs access to the same value from the cookies, 
we need to explicitly set the key value in both configuration objects.

Be sure to add the key with the cookie name to the session middleware 
that matches the Socket.IO key. Also, add the store reference to the options, 
near where we set saveUninitialized: true. 
This is necessary to tell Socket.IO which session to relate to.

Now, define the success, and fail callback functions:

function onAuthorizeSuccess(data, accept) {
  console.log('successful connection to socket.io');

  accept(null, true);
}

function onAuthorizeFail(data, message, error, accept) {
  if (error) throw new Error(message);
  console.log('failed connection to socket.io:', message);
  accept(null, false);
}
The user object is now accessible on your socket object as socket.request.user. 
For example, now you can add the following:

console.log('user ' + socket.request.user.username + ' connected');
It will log to the server console who has connected! */

/*Many chat rooms are able to announce when a user connects or disconnects 
and then display that to all of the connected users in the chat. 
Seeing as though you already are emitting an event on connect and disconnect, 
you will just have to modify this event to support such a feature. 
The most logical way of doing so is sending 3 pieces of data with the event: 
the username of the user who connected/disconnected, the current user count, 
and if that username connected or disconnected.

Change the event name to 'user', and pass an object along containing 
the fields username, currentUsers, and connected (to be true in case of connection, 
or false for disconnection of the user sent). Be sure to change both 'user count' 
events and set the disconnect one to send false for the field connected instead 
of true like the event emitted on connect.

io.emit('user', {
  username: socket.request.user.username,
  currentUsers,
  connected: true
});
Now your client will have all the necessary information to correctly 
display the current user count and announce when a user connects or disconnects! 
To handle this event on the client side we should listen for 'user', 
then update the current user count by using jQuery to change the text 
of #num-users to '{NUMBER} users online', as well as append a <li> to the unordered
 list with id messages with '{NAME} has {joined/left} the chat.'.

An implementation of this could look like the following:

socket.on('user', data => {
  $('#num-users').text(data.currentUsers + ' users online');
  let message =
    data.username +
    (data.connected ? ' has joined the chat.' : ' has left the chat.');
  $('#messages').append($('<li>').html('<b>' + message + '</b>'));
}); */

/*It's time you start allowing clients to send a chat message to the server to 
emit to all the clients! In your client.js file, you should see there 
is already a block of code handling when the message form is submitted.

$('form').submit(function() {
  /*logic
});
Within the form submit code, you should emit an event after you define 
messageToSend but before you clear the text box #m. The event should be 
named 'chat message' and the data should just be messageToSend.

socket.emit('chat message', messageToSend);
Now, on your server, you should be listening to the socket for 
the event 'chat message' with the data being named message. 
Once the event is received, it should emit the event 'chat message' 
to all sockets using io.emit, sending a data object containing the username and message.

In client.js, you should now listen for event 'chat message' and, 
when received, append a list item to #messages with the username, 
a colon, and the message!

At this point, the chat should be fully functional and sending messages across all clients!

Submit your page when you think you've got it right. If you're running into errors, 
you can check out the project completed up to this point. */

/*"dependencies": {
    "bcrypt": "~5.0.0",
    "connect-mongo": "~3.2.0",
    "cookie-parser": "~1.4.5",
    "dotenv": "^8.2.0",
    "express": "^4.16.1",
    "express-session": "~1.17.1",
    "mongodb": "^3.6.1",
    "passport": "^0.4.1",
    "passport-github": "~1.1.0",
    "passport-local": "~1.0.0",
    "passport.socketio": "~3.7.0",
    "pug": "~3.0.0",
    "socket.io": "~2.3.0"
  } */`Listening on port ${PORT}`);
});

